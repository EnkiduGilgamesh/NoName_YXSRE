       代码编辑及配音问题
（1）工具推荐：首先要成为一名代码编辑者，一个合适的文档编辑工具是必不可少的。手机编辑推荐下载MT管理器，windows编辑推荐下载Notepad++。
（2）熟悉路径：脱离游戏自带的编辑器编写代码，首先你需要知道你的noname文件夹放在哪个路径下。还不知道的可以在游戏的命令行中敲入lib.assetURL，回车即可查看noname所在路径，按照路径去找你的noname文件夹。主要文件有：
card/*.* 游戏牌代码
character/*.* 武将代码（含技能代码）
game/game.js 游戏代码
（3）摸索建议：比如你要写一段技能，涉及“移动场上的一张牌”，但不知道代码怎么写。那么打开character文件夹的一个文件，查找有关这个描述的代码研究一下。一个研究不懂就多找几个对比研究，有思路了就自己动手尝试一下。
MT管理器自带的文件编辑器以及notepad++均有查找功能，可以帮助你快速定位代码所在。
讲解时机之前先讲技能的分类，一般分为四大类：触发类（如遗计，受到伤害即触发）、主动类（如攻心，出牌阶段主动对其他角色发动技能）、视为类（将一种牌视为另一种牌使用或打出，如武圣、倾国）、Mod类（可以理解为固定死的技能，一般是弄不了配音的，如马术）。
时机:
主动类这样写：
enable:"phaseUse", 表示出牌阶段，phase是阶段的意思
 usable:1, 数字可以更改，表示可发动次数
触发类：
格式：trigger:{触发者:"触发时机"},
触发者先确定是谁触发，一般有三种：场上的人写global ， 自己写player ， 自己为来源写source 。
比如：其他角色受到伤害后：trigger:{global:"damageEnd"}, 
你受到伤害后：trigger:{player:"damageEnd"}, 
你造成伤害后：trigger:{source:"damageEnd"},
触发时机大致有以下这些，替换上边的damageEnd 就会诞生新的技能，当然不是生搬硬套，得符合逻辑：
gameDrawAfter 所有人摸牌结束之后，游戏开始
phaseBofore 回合开始前
phaseBegin 回合开始阶段
phaseJudgeBegin 判定阶段开始时
phaseJudgeBefore判定阶段开始前
phaseJudge 判定阶段
phaseDrawBefore摸牌之前
phaseDrawBegin摸牌之时
phaseDrawEnd摸牌结束
phaseUseBefore出牌阶段之前
phaseUseBegin出牌阶段开始时
phaseUseEnd出牌阶段结束时
phaseDiscardBefore弃牌阶段之前
phaseDiscardBegin弃牌阶段开始时
phaseDiscardEnd弃牌阶段结束时
phaseEnd回合结束时
loseEnd失去一张牌时
gainEnd获得一张牌后
chooseToRespondBegin打出一张牌响应之前
chooseToUseBegin使用一张牌后
damageEnd
视为类：
有回合内主动视为（ enable:["chooseToUse","chooseToRespond"],）和回合外响应视为（trigger:{ player:["useCard","respond"], },）
若当你造成或受到伤害则这样写：trigger:[source:"damageEnd",plsyer:"damageEnd"], 技能组的形式。
触发技，如果是某个角色只针对你用牌比如杀／桃时／后，可直接写为trigger:{target:["shaBegin",taoAfter"],},

常用词汇：trigger触发，phase阶段， player玩家，current当前玩家， target目标， global场上所有角色， event事件，card牌， handCard手牌 ，equip装备牌， trick锦囊牌，delay延时性锦囊， h手牌， e装备牌 ， j判定牌， hp体力（即是血量）， maxHp体力上限， damage受伤 ， lose失去， recover回复体力， discard弃置牌， draw摸牌， step 步骤，fire火焰伤害，thunder雷属性伤害，true成功， false失败，storage可理解为技能的标记，mark标记，countCard牌数， result结果，random随机，compare比较、拼点，gain获得，$gain2 给出牌，skill技能， add增加，type类型，basic基本牌，color卡牌颜色，spade黑桃，heart红桃，club梅花，diamond方片
举例：目标受到一点火焰伤害：target.damage('fire'); 你摸3张牌：player.draw(3);
注：受伤和失去体力是不一样的，语句结束用分号；函数框架结束用逗号，所有符号都要英文输入法状态，代码里出现中文一般要用英文单引用 ‘’ 括着。

写技能时一定要切记技能的 ID 要保持一致，否则技能会失败产生BUG，配音也不会出声音。然后技能的命名格式为：id|技能名，id一般最好用英文小写，中间有个英文竖。

编写完代码保存重启后，再进入你的扩展里增加武将，然后添加技能（此扩展），这个不用介绍了吧？保存重启。然后将配音文件手动粘贴到extension-你的扩展 里，然后压缩－全选所有文件－压缩，压缩完后将压缩包改回扩展名，然后扩展包完成了。

自定义势力:
lib.group.push('英文名');
lib.translate.英文名='中文名'; lib.translate.英文名Color="#FFFF00（这是势力字体颜色）"
你自己造个扩展，主代码写这个，自己造个角色势力随便，然后保存重启，之后在管理器内把你那个角色的势力的英文名改成你造的那个势力英文名，之后保存在从启游戏，不对就看一下主代码里代码是不是没了或者哪里打错了。

如何为技能添加效果？比如天义拼点赢能增加技能效果：两次杀，额外杀一人。用player.addTempSkill('新技能名',{player:'直到的时机'});
一些关于符号的知识点：
！　表示否定，不。举例：!=　表示不等于；return !player==target; 表示返回值为玩家不是目标；
==　表示等于。举例：player==target;玩家是目标；trigger.num==1;触发值为1；
+=/-= 表示加/减多少。举例：trigger.num+=2;　表示触发值+2；（常用于受伤后伤害值加多少）；
|| 　英文输入法输入的双竖线，比较常见，表示“或”、“或者”。举例：player.hp>=1||player.countCards('h')>0; 表示体力值不小于1或手牌数大于0；
&& 两个&符号表示“且”、“而且”，举例：player.hp>=1&&player.countCards('h')>0; 表示体力值不小于1而且手牌数大于0；
注：无穷大为：lnfinity 　　无穷小为：-lnfinity

技能组：当一个技能拥有多种效果但又不想将它们独立成单个技能（为了不让技能过多），可以用技能组的形式。
一般有几种写法：1、先单独做子技能xxx1和xxx2……，再另做一个技能xxx，里面用代码group:["xxx1","xxx2"……],将些子技能包装起来。如技能“无双”；
2、在一个技能里写完所有的子技能，用subSkill来分开写子技能，具体格式参考灵雎的“竭缘”；
3、在主技能内独立于content:function外用group:"xxx2",或group:["xxx1","xxx2"……],来写，附带技能的后续后果，如岑昏的“极奢”；

续补:
前言：
 (1)每写一个对象前，请确认是否有这一对象，没有的话请自行定义
 (2)检测bug用lib.node.debug()
 (3)具体触发内容看game.js内lib.element.event内的函数
 (4)本教程只教框架
1.触发：
 基本框架：
 trigger:{//触发时机
 global:'damageBefore',//例子，任意一名角色受到伤害前
 player:'damageBefore',//例子，玩家受到伤害前
 player:['damageBefore','recoverAfter'], //例子，玩家受到伤害前或玩家恢复体力后
 },
 priority:1,//同时机技能发动的优先度
 check:function(event,player){//告诉ai是否发动这个技能，返回true则发动此技能
 //无例子，因为不同时机evevt参数内的元素不同
 //要了解evevt参数内的元素，具体看game.js内lib.element.event内的函数 
 },
 frequent:true,//此技能是否可以被设置为自动发动（不询问）
 forced:true,//此技能是否能固定触发，true为固定触发（锁定技）
 popup:false,//player是否logSkill('此技能')
 direct:true,//相当于上面两行相加
 filter:function(event,player){//触发条件，返回true则发动此技能
 //无例子，因为不同时机evevt参数内的元素不同
 //要了解evevt参数内的元素，具体看game.js内lib.element.event内的函数
 },
 content:function(){//触发内容，分步执行会在后面讲到
 //参数trigger相当于filter:function(event,player){}内的event
 player.recover()//例子，玩家回复一点体力
 },
2.主动：
 基本框架：
 enable:"phaseUse",//出牌阶段使用
 usable:1,//每回合限制使用次数 
 //限制使用次数为变量时需写在filter:function(event,player){}内
 filter:function(event,player){//发动条件，返回true则可以发动此技能
 /*限制使用次数为变量时:
 if(player.getStat().skill['技能名']>=变量) return false;（变量可以写player.hp等）
 return true;
 */
 returnplayer.hp<2;//例子，玩家体力小于2时可以发动
 },
 filterCard:function(card){//选择的牌需要满足的条件
 returnget.color(card)=='red';//例子，只能选择红色牌
 },
 position:'hej',//可以选择什么位置的牌
 //写入其中的字符：'h'：手牌区, 'e'：装备区, 'j'：判定区
 selectCard:2,//需要选择多少张牌才能发动
 //为-1时，选择所有牌
 //为数组时，这个数组就是选择牌数的区间
 /*为变量时（具体情况具体分析）:
 function(card){//例子，变量为玩家体力时
 var pl=get.owner(card);//pl定义为选择牌中的牌的拥有者，即“你”
 return [pl.hp,Infinity];//返回可选手牌数为你的体力值到无限
 },
 */
 check:function(card){//ai应该如何选牌，返回值为正则此牌可选，反之，此牌不可选
 /*在check中定义玩家（你）：
 var player=get.owner(card);
 */
 return6-get.value(card);//例子，ai可选价值小于6的卡牌
 },
 discard:false,//是否弃牌，若没有这一行，选择牌发动技能后，被选择的牌都要弃置
 prepare:'give',//不弃牌，准备用这些牌来干什么
 filterTarget:function(card,player,target){//选择的目标需要满足的条件
 returntarget!=player;//例子，目标不是玩家
 },
 selectTarget:1,//需要选择多少个目标才能发动
 //为-1时，选择全部人
 //为数组时，这个数组就是选择目标数的区间
 multitarget:true,//是否每个目标都结算一次，true为否
 targetprompt:[],//选择的目标武将牌上出现什么字，数组第几元素对应第几个目标
 line:true,//选择目标，发动技能后，玩家指向目标
 content:function(){//触发内容，分步执行会在后面讲到
 //当有filterCard时，有参数cards
 //当有filterTarget时，有参数target和targets
 player.recover()//例子，玩家回复一点体力
 },
3.视为：
（1）转化为一张卡牌：
 基本框架：
 name:'技能',//技能按钮名字，不写则默认为此技能的翻译
 enable:['phaseUse','chooseToRespond'],//发动视为技的时机，现在为出牌阶段和响应时
 viewAsFilter:function(player){//视为技按钮出现条件（即发动条件）
 returnplayer.maxHp==4;//例子，玩家体力上限为4时可以发动
 },
 filterCard:{type:'basic'},//选择的牌需要满足什么条件
 /*上面那种是简便写法，多次判断的话还是要写回旧格式：
 filterCard:function(card){
 return get.color(card)=='black';//例子，只能选择黑色牌
 },
 */
 position:'hej',//可以选择什么位置的牌，和主动的position相同，不解释
 selectCard:2,//需要选择多少张牌才能发动，和主动的selectCard相同，不解释
 check:function(card){//ai应该如何选牌，和主动的check相同，不解释
 return1;//例子，ai可以所有所有手牌
 },
 viewAs:{name:'tao'},//目标卡牌
 prompt:'将一张基本牌当桃使用或打出',//选择时弹出的提示
 onuse:function(result,player){//使用视为牌时触发内容，result.cards是视为前的牌
 player.recover();//例子，使用视为牌时玩家回复一点体力
 },
（2）转化为多张卡牌：
 基本框架：
 enable:'phaseUse',//发动视为技的时机，现在为出牌阶段
 usable:1,//每回合限制使用次数，和主动的usable相同，不解释
 filter:function(event,player){//发动条件，和主动的filter相同，不解释
 returnplayer.countCards('h')>0//例子，玩家手牌数大于0时可以发动
 },
 chooseButton:{//选择按钮（牌）
 dialog:function(){//选择内容，一般为选择卡牌，有能力的可以写成选择其他东西
 returnui.create.dialog([['sha','shan'],'vcard']);//可以选择杀和闪（卡牌）
 },
 filter:function(button,player){//卡牌选择条件
 returnlib.filter.filterCard({name:button.link[2]},player,_status.event.getParent());
 //例子，你可以选择你可以使用的卡牌
 },
 check:function(button){//ai如何选牌
 /*定义player：
 varplayer=_status.event.player;
 */
 if(button.link=='sha')return 1;//ai选择杀
 },
 backup:function(links,player){//返回视为（1）部分
 return {//例子
 filterCard:false,//不用弃牌
 selectCard:0,//弃牌数为零
 viewAs:{name:links[0][2]},//视为你使用你选择的牌
 };
 },
 prompt:function(links,player){//选择时弹出的提示
 return'请选择'+get.translation(links[0][2])+'的目标';
 //例子，弹出提示：选择你选择的牌的目标
 },
 },
4.AI：
 (注：可接视为框架、主动框架或触发框架)
 (注2：这部分我不是很熟悉，所以只能简单地说一下)
 基本框架：
 ai:{
 save:true, //此技能可以用于自救
 respondTao:true, //此技能可以用于救人，一般用于视为技
 respondShan:true,//此技能可以响应闪，一般用于视为技
 respondSha:true,//此技能可以响应杀，一般用于视为技
 order:8, //ai发动技能的优先度
 /*比什么先：
 order:function(){//例子，比打出杀的优先度高1
 return get.order({name:'sha'})+1;
 },
 */
 expose:0.2, //发动技能是身份暴露度（0~1，相当于概率）
 maixie:true, //卖血技
 threaten:0.5,//嘲讽值
 result:{//主动技专属
 target:function(player,target){//ai如何选择目标
 //返回负，选敌人，返回正，选队友
 //没有返回值则不选
 //写了这个就不用写player:function(player){}了
 //因为player可以在这里进行判断
 If(player.hp>2)return -1;//例子，玩家体力大于2时，发动技能并选择敌人
 },
 player:function(player){//ai是否发动此技能，返回正，发动，否则不发动
 if(player.countCards('h')<2)return 1;//例子，玩家手牌数小于2时，发动 },
 },
 effect:{//影响ai出牌（例如什么时候不出杀）等
 //没有深入研究，不讲
 },
 skillTagFilter:function(player){//视为技专属，ai什么时候可以发动视为技
 returnplayer.countCards('h',{type:'basic'})>0;
 //例子，手牌中有基本牌时，ai发动技能
 },
 },

5.标记：
(注：可接视为框架、主动框架或触发框架)
 基本框架：
 marktext:"状",//标记显示文本，一般为一个字
 locked:true,//是否实时更新
 intro:{
 content:'cards',//标记显示内容，为cards时显示标记内的牌
 /*标记显示内容为文本写法：
 content:function(storage,player,skill){//返回值（文本）即为标记显示内容
 return '当前有'+storage+'个标记'//标记显示内容为当前有多少个标记
 },*/
 },
 mark:true,//获得技能时是否显示此标记，若为false，可以用markSkill()来显示此标记
6.获得技能和失去技能时：
(注：可接视为框架、主动框架或触发框架)
 基本框架：
 init:function(player){//获得技能时发动
 player.gainMaxHp();//例子，获得此技能时，玩家增加一点体力上限
 },
 onremove:function(player){//失去技能时发动
 player.loseMaxHp();//例子，失去此技能时，玩家失去一点体力上限
 },
7.技能组与子技能：
(注：可接视为框架、主动框架或触发框架)
 基本框架：
 group:["mashu"],//技能组，拥有这个技能时相当于拥有技能组内的技能
 subSkill:{//子技能，你不会拥有写在这里面的技能，可以调用，可以用技能组联系起来
 "子技能":{//子技能名字:“主技能_子技能”，翻译为主技能翻译
 //技能内容
 },
 },
8.mod类锁定技：
(注：可接视为框架、主动框架或触发框架)
 基本框架：
 mod:{
 globalFrom:function(from,to,distance){
 returndistance-1; //例子，进攻距离+1
 },//from：玩家；to：目标；distance：进攻距离
 globalTo:function(from,to,distance){
 returndistance+1; //例子，防御距离+1
 },//to：玩家；from：目标；distance：防御距离
 maxHandcard:function(player,num){
 return num+1; //例子，手牌上限+1
 },// player：玩家；num：手牌上限
 targetEnabled:function(card,player,target){
 if(player.sex=='male')return false; //例子，你不能成为男性角色的牌的目标
 },//card：牌；player：使用牌的角色；target：玩家
 selectTarget:function(card,player,range){
 if(card.name=='sha')range[1]+=1; //例子，你的杀可以额外选择一名角色
 },//card：牌；player：玩家；range[1]：目标个数; range：不清楚
 targetInRange:function(card,player,target){
 if(card.name=='sha')return true;//例子，你使用的杀可以指定所有角色
 },//card：牌；player：玩家；target：目标
 cardDiscardable:function(card,player){
 if(card.name=='sha')return false; //例子，你无法弃置杀
 },//card：牌；player：玩家
 cardEnabled:function(card,player){//要与cardUsable一起使用
 if(get.suit(card)=='heart')return false;//例子：你无法使用红桃牌
 },//card：牌；player：玩家
 cardUsable:function(card,player){//要与cardEnabled一起使用
 if(get.suit(card)=='heart')return false; //例子：你无法使用红桃牌
 },//card：牌；player：玩家
 cardRespondable:function(card,player){
 if(get.suit(card)=='heart')return false; //例子：你无法使用红桃牌来响应
 },//card：牌；player：玩家
 cardSavable:function(card,player){
 if(get.suit(card)=='heart')return false; //例子：你无法使用红桃牌来救人
 },//card：牌；player：玩家
 /*后4种卡牌禁言类mod技与视为技冲突的解决方法：
 判定内加入_status.event.skill!='冲突视为技'
 意思为你无法使用牌，除非使用这个视为技视为无法使用的牌
 */
 },
9.配音的添加：
(注：可接视为框架、主动框架或触发框架)
 基本框架：
 //数字为配音数量，从1开始
 //配音命名方法：技能名+这是第几个配音
 audio:2,//使用无名杀目录\audio\skill内的配音
 audio:"ext:扩展名:1",//使用无名杀录目\extension \扩展名内的配音
10.主公技：
(注：可接视为框架、主动框架或触发框架)
 基本框架：
 zhuSkill:true,//将这个技能设置为主公技
11.全局技能：
(注：可接视为框架、主动框架或触发框架)
(注：无论是否拥有此技能，此技能都为全局技能写法：技能名前+_)
 基本框架：
 global:'技能',你用有此技能时，所有角色拥有技能（global的值）
12.触发内容分步：
(注：写在触发内容中)
 基本框架：
 'step0'
 //此步骤触发的内容
 'step1'
 //此步骤触发的内容
与步骤有关的函数：
(1)evevt.finish() 触发后步骤不再往下走，终止于evevt.finish()所在步骤
(2)event.goto(num) num为步骤数，返回第几步
(3)event.redo() 重新执行这个步骤
注意：
(1)引号要相同，不要'step 0' "step 1"
(2)使用与步骤有关的函数，这个步骤依旧会进行到底
(3)var定义的东西不能在步骤中传递，可以储存到evevt中
(4)函数的result元素可以在相邻的步骤中传递
(5)步骤必须从0开始
(6)step和数字之间有一个空格，word文档中不易看出来
例子：
 "step0"//步骤0
 player.chooseTarget('请选择一名角色',function(card,player,target){
 returnplayer!=target;
 }).ai=function(target){
 returnget.attitude(player,target);//告诉ai选择队友
 };//选择一名其他角色
 "step1"//步骤1
 if(result.bool){//如果有选择角色
 event.target=result.targets[0];//将选择的角色储存到event.target中
 player.chooseCard('请选择给予牌',2,'h').set('ai',function(card){
 return1;//告诉ai可以选择所有手牌
 });//选择两张手牌
 }else{//否则
 event.finish();//步骤将于这里终止
 };
 "step2"//步骤2
 if(result.bool){//如果有选择手牌
 player.$give(result.cards.length,event.target);
 event.target.gain(result.cards,player);//被选择的角色获得这两张牌
 };

AI:
1.2 AI获取(玩家):
ai.get.attitude(玩家1,玩家2):『态度值检测』检测玩家1对玩家2的态度值;
ai.get.effect(target,content,player,viewer):『效果检测』检测卡牌/技能对目标角色的效果值,content代表卡牌或者技能,例如
{name:'sha'}/'挑衅';viewer代表视角,一般填player或者target,例如我方杀敌方满血『曹丕』,对我方来说是负效果,但对敌方是正效果,
视角决定效果的正负。
ai.get.damageEffect(玩家1,玩家2,viewer,nature):『检测伤害效果』这里检测的是[玩家2对玩家1]的伤害效果,nature代表属性(雷/火);
ai.get.recoverEffect(玩家1,玩家2,viewer):『检测回复效果』 与上段类似;
ai.get.effect(target,content,player,viewer)这句的viewer假如省略不写，viewei默认为玩家player,公式为:总效果=对使用者的收益值*使用者对自己的att+对目标的收益值*使用者对目标的att; 假如viewer不为player,公式为:总效果=对使用者的收益值*使用者对自己的att+对目标的收益值*viewer对目标的att;

1.3 AI获取(卡牌)：
useful：回合外留牌的价值(弃牌阶段按useful顺序选)
value：牌的使用价值(五谷按value顺序选)
举例:ai.get.useful(card)/ai.get.value(card)

『2』AI的分类与写法：
2.1 AI的合理位置
1.AI须选择角色/卡牌/按钮等等时
2.check中检测条件时的收益时
3.主动技的结尾,用来检测是否发动和对谁发动
4.需要声明有某技能时某牌的使用效果发生改变时(大部分是卖血技)

2.2 不同位置的AI写法
2.2.1 选择(choose类):
target.chooseToDiscard().ai=function(card){
return 8-ai.get.value(card);
}
return 8-ai.get.value(card)这句是告诉AI如果手里有价值小于8的牌就弃置,否则不弃置
弃置的规则是价值越小的牌优先丢,一个return 5和return 3 AI会选return 5的卡牌。
当return值不大于0时,例如最后一张手牌价值为9 (return 8-9)=-1,AI将会放弃。
target.chooseTarget().ai=function(target){
return ai.get.attitude(player,target);
}
同理,att值越大的会优先选。注意att值只与身份有关,一个鲁肃一个于禁队友,并不一定会选鲁肃。
player,chooseControl('摸牌','回血').ai=function(event,player){
if(player.hp>=2) return '摸牌';
return '回血';
}

2.2.3 主动技结尾
一般格式为:
ai:{
order:xx,
threaten:xx,
//上述为定义/标签
result:{
player:xx;
target:xx;
}
//收益值
}

『3』收益论
3.1 收益论用途
1.告诉AI会发动技能,
2.告诉AI会卖血,
3.告诉AI倾向于卡牌/行为,

3.2 收益论名词:
result:『收益』收益值未在AI声明默认为0(对玩家对目标均是如此).收益值可以直接在AI声明;
result在player部分里声明就是对玩家的收益,在target部分里声明就是对目标的收益;
effect:『效果』效果值为正代表正效果,反之为负效果,AI会倾向于最大效果的目标/卡牌;
attitude:『态度』态度只由identity决定。不同身份对不同身份的att不同。例如在身份局中,主对忠att值为6,
忠对主att值为10;

3.3 收益论应用:
3.3.1 【主动技】:
•如果技能发动无须指定目标: effect=result*ai.get.attitude(player,player);
即: 总效果=收益值*使用者对自己的att;
举例『制衡』:
ai:{
result:{
player:1
}}
*由于制衡基本是每回合都会发动,所以AI中将『收益值』直接定为1,假设孙权对自己的att为10,这将代表：
总效果=(1)收益值*(10)=10;由于效果值为正(正收益) 所以AI将会发动『制衡』
举例『急袭』:
ai:{
order:10,
result:{
player:function(player){
return player.storage.tuntian.length-1;
}}}
*这个很容易看出来,只有一个田就不发动了...只要田大于1,对使用者就是正收益,再乘以对自己的att,也是正效果,所以AI将会发动『急袭』

•如果技能发动须指定目标
总效果=对使用者的收益值*使用者对自己的att+对目标的收益值*使用者对目标的att;
实际还会考虑嘲讽值,这里简化了;
举例『挑衅』:
ai:{
order:4,
expose:0.2,
threaten:1.1,
result:{
target:-1,
//直接定义目标的收益值为-1,
player:function(player,target){
if(target.num('h')==0) return 0;
if(target.num('h')==1) return -0.1;
if(player.hp<=2) return -2;
if(player.num('h','shan')==0) return -1;
return -0.5;
//上述表示目标角色不同的情况,玩家将会return不同的收益值;
}}}
『挑衅』是一个作死技,技能发动对自己没有正收益,只会给目标角色带来负收益。所以
player部分中收益值最大也不会超过0,因为是弃置对方一张牌,所以直接将目标角色的收益
定为了-1;如果对自己的负收益大于对敌方的负收益的话,姜维将不会发动『挑衅』
举例『排异』:
ai:{
order:1,
result:{
target:function(player,target){
if(player!=target) return 0;
if(player.num('h')+2<=player.hp+player.storage.quanji.length) return 1;
return 0;
}}}
『排异』为什么没有声明player部分呢,因为除非你排异自己,否则你自己是没收益的,只是对你选择的目标
有收益(摸2牌)。

这个get.tag是什么意思呢？其实和技能标签一样,卡牌也有自己的标签,例如
杀:{
tag:{
respond:1,
respondShan:1,
damage:function(card){
if(card.nature=='poison') return;
return 1;
}}}
为了方便删了一些tag,那么『杀』有如下tag:respond;respondShan;damage等等,所以get.tag(card,'damage')
代表有伤害属性的卡牌,例如杀,南蛮,决斗等等。
*特别注意ai里面的effect是上帝视角,target不代表目标角色,player也不代表拥有此技能的玩家本身,
因为effect是写给别的AI看的,所以target代表玩家本身,player代表其他人,可以是正在犹豫是否要杀
你的任何一位玩家。
那么队友会杀卖血流队友还是杀敌方呢？还是套公式:
总效果=对使用者的收益值*使用者对自己的att+对目标的收益值*使用者对目标的att;
因为『杀』对使用者是没收益的,所以公式变为:
总效果=对目标的总收益值*使用者对目标的att;
比如杀对目标角色的收益是-1.5,满血曹丕的effect是return [0.5,1],那最终的收益是0.25,如果对曹丕的attitude是1,对某白板敌人的attitude是-1,那杀曹丕的效果为1*0.25,
杀敌人的效果为-1*-1.5,所以最终会选敌人(实际稍复杂点,详见ai.get.effect函数)

3.3.2 【倾向技】
这个占比例非常少,略说明一下
举例『忘隙』:
ai:{
effect:{
player:function(card,player){
if(card.name=='nanman'||card.name=='wanjian') return [1,3];
}}}
这里的意思是尽量放南蛮万剑之类,类似的,激昂也是强调AI尽量用红杀;
因为上述AI中effect里面的为player,所以代表的是对使用者的收益。

3.4收益论的检验
enable:'phaseUse',
filterTarget:true,
content:function(){
game.log(player,'对',target,'的att是',ai.get.attitude(player,target));
game.log(player,'对',player,'的att是',ai.get.attitude(player,player));
game.log(player,'对',target,'发动【测试】的eff是',ai.get.effect(target,'测试',player,player));
game.log(player,'对',target,'使用【杀】的eff是',ai.get.effect(target,{name:'sha'},player,player));
},
ai:{
result:{
target:-10,
player:-2,
},
effect:{
player:function(card,player){
if(card.name=='sha') return [0,1];
}
}
}

game.js黑科技:
discardPlayerCard：弃置目标角色的一张牌，
gainPlayerCard：获得目标角色的一张牌，
viewHandcards：观看目标手牌
举例：
player.discardPlayerCard('he',target);
player.gainPlayerCard('he',target);
player.viewHandcards(target)

directergain:暂时未知，和gain差不多
useSkill:发动技能，
doubleDraw:双将有单独的阴阳鱼会出现令你doubleDraw
举例：
player.directgain(get.cards());
player.useSkill('fangzhu',target);//对目标发动“放逐”
player.doubleDraw();//发动会提示你有单独的阴阳鱼，是否摸一张牌
directergain:直接获得卡牌，不触发任何技能
isMad：判断是否进入混乱状态，
goMad：进入混乱状态，
unMad：解除混乱状态，
举例：
player.goMad();
out:加入/离开游戏，
skip:跳过，目前只发现了跳过阶段，
logSkill:用于控制direct技能的配音和历史记录的节点，
举例：
target.out();
player.skip('phaseDiscard');
player.logSkill('guicai');
prompt:提示语，‘
popup:显示某项内容(在武将牌上显示)，
markCharacter:标记武将，
举例：
prompt:'弃置任意张牌并摸等量的牌',
player.popup(player.name);
getStat:获取数量(计数)’，
isEnemyOf:某某的敌人，
isFriendOf:某某的队友，
举例：{
var num=player.getStat().skill.danshou;
if(player.getStat('damage'));
if(player.getStat().card.sha);
if(target.isEnemyOf(player))
if(target.isFriendOf(player))

isAlive:存活，
isDead:死亡；
isDamaged:受伤，
举例：
return target.isAlive();

enable:'phaseUse',
//filterTarget:true,
content:function(){
player.$skill('观星');
player.$fire();
player.$thunder();
player.$rare2();
player.$epic2();
player.$legend2();
player.$rare();
player.$epic();
player.$legend();
player.$coin();
player.$dust();
player.$recover();
player.$fullscreenpop();
player.$damagepop();
player.$damage();//朝伤害来源相反的方向缩放武将牌
player.$die();//扭转武将牌，也就是阵亡效果
player.$gain(get.cards());//弹窗式的获得卡牌
player.$gain2(get.cards());//摸牌式的获得卡牌
}

swap系列：
swapSeat:交换座位，
swapPlayer:交换控制权，
swapControl:由玩家完全控制某个另一个玩家，但不交换控制权，也不交换座位和视角，当玩家控制别的玩家时，玩家本身会处于托管状态，也不能看见自己的手牌。
举例：
game.swapSeat(player,target);
game.swapPlayer(player,target);
game.swapControl(target);



看到不少扩展的人物头像很违和，其实这有个小技巧，将人物截剪成长：宽为4：3，头部在上三分之一即九宫格中宫直上那个格内，居中间稍偏右黄金分割是最完美的！

自定义势力颜色:
例：新版本「Key杀」中自定义【键】势力的相关代码
//设置势力的颜色
//这个步骤是在样式库中写入需要的势力颜色 rgba里面的四个数字就代表颜色的RGB值和透明度
 var style2=document.createElement('style');
 style2.innerHTML=".player .identity[data-color='key'],";
 style2.innerHTML+="div[data-nature='key'],";
 style2.innerHTML+="span[data-nature='key'] {text-shadow: black 0 0 1px,rgba(203, 177, 255,1) 0 0 2px,rgba(203, 177, 255,1) 0 0 5px,rgba(203, 177, 255,1) 0 0 10px,rgba(203, 177, 255,1) 0 0 10px}";
 style2.innerHTML+="div[data-nature='keym'],";
 style2.innerHTML+="span[data-nature='keym'] {text-shadow: black 0 0 1px,rgba(203, 177, 255,1) 0 0 2px,rgba(203, 177, 255,1) 0 0 5px,rgba(203, 177, 255,1) 0 0 5px,rgba(203, 177, 255,1) 0 0 5px,black 0 0 1px;}";
 style2.innerHTML+="div[data-nature='keymm'],";
 style2.innerHTML+="span[data-nature='keymm'] {text-shadow: black 0 0 1px,rgba(203, 177, 255,1) 0 0 2px,rgba(203, 177, 255,1) 0 0 2px,rgba(203, 177, 255,1) 0 0 2px,rgba(203, 177, 255,1) 0 0 2px,black 0 0 1px;}";
 document.head.appendChild(style2);
 //在lib.groupnature中建立相应的映射
 lib.groupnature.key='key';
 //将势力添加到势力库中 并指定势力的中文名称
 lib.group.push('key');
 lib.translate['key']='键';

新函数:
get.bottomCards()
为许攸量身定做的新函数
用法和get.cards()完全一致 只不过这个函数得到的是牌堆底的牌 而那个函数得到的是牌堆顶的牌 就是这样
如果要从牌堆底摸牌的话 在括号里加上一个 'bottom' 即可
例：player.draw(2,'bottom'); 效果即为让玩家从牌堆底摸两张牌
或者可以写成 player.draw(2).set('bottom',true); 效果和之前的函数一致

然后是废除装备栏的写法 例：
一： player.disableEquip(2);
二： player.disableEquip('equip2');
两种写法的效果一样 都是废除玩家的防具栏#(滑稽) 
1=武器栏 2=防具栏 3=加一马栏 4=减一马栏 5=宝物栏 就是这样
一次性废除多个装备栏的话 请将这段代码复制几遍
例：
player.disableEquip(1);
player.disableEquip(2);
...

判断玩家一个装备栏有没有被废除 请使用player.isDisabled()函数
例：假设有一个孙笨 废除了自己的武器栏#那么
用 player.isDisabled(1) 就可以判断出孙笨的武器栏已经被废除
也可以写成 player.isDisabled('equip1') 效果依然一样

判断玩家的某个装备栏是不是“空栏”（即既没有被废除 栏内也没有装备牌） 请使用player.isEmpty()函数
例：一个装着武器的孙笨 player.isEmpty(1)函数得到的结果为false
一个废除了防具栏的陆抗 player.isEmpty(2)得到的结果为false
一个宝物栏里没有宝物牌 也没有废除宝物栏的SP黄月英 player.isEmpty(5)得到的结果为true
括号里面也可以填文字 用法和之前类似

废除判定区
直接使用 player.disableJudge(); 即可
括号里面什么都不用填  不过目前没有恢复判定区的函数 因此慎用



player.countDisabled();
这个函数的作用是统计玩家一共废除了多少个装备栏
player.chooseToDisable();
这个函数的作用是让玩家选择废除一个装备栏
例：陆抗技能【决堰】
...
'step 0'
 player.chooseToDisable(true).set('ai',function(event,player,list){
 if(list.contains('equip2')) return 'equip2';
 if(list.contains('equip1')&&player.countCards('h',{name:'sha'})>2) return 'equip1';
 if(list.contains('equip5')&&player.countCards('h',{type:'trick'})>=1) return 'equip5';
 });
 'step 1'
 if(result.control=='equip1'){
 player.addTempSkill('drlt_jueyan1',{player:'phaseAfter'});
 };
 if(result.control=='equip2'){
 player.draw(3);
 player.addTempSkill('drlt_jueyan3',{player:'phaseAfter'});
 };
 if(result.control=='equip6'){
 player.addTempSkill('drlt_jueyan2',{player:'phaseAfter'});
 };
 if(result.control=='equip5'){
 player.addTempSkill('rejizhi',{player:'phaseAfter'});
 };
括号里的true 作用是让玩家在选择时 把两个坐骑栏放在一起废除(之后对应的结果是equip6)

player.chooseToEnable();
让玩家选择并恢复一个装备栏
game.cardsDiscard();
这个函数的作用是「将不属于任何人的卡牌置入弃牌堆」把要弃置的卡牌填进括号就行
chooseToPSS()
石头剪刀布的函数 用法和拼点类似
例:player.chooseToPSS(target);
如果发起玩家胜利 那么result.bool值为true 失败则为false 如果平局 那么result.tie值为true
chooseToDuiben();
对一名其他角色发起对笨(划掉)对策
为审配专门加入的函数 用法和石头剪刀布类似 只不过没有平局的结果
顺便 发起人在对策过程中是选择防御策略的角色 在用的时候不要搞错了

player.canCompare(target) 用于判断玩家能否和目标角色拼点
众所周知 按照三国杀规则 拼点发起者想和一名角色拼点 需要满足以下条件：
1. 拼点发起者不是拼点目标
2. 拼点发起者和拼点目标都有手牌(所以别指望秦宓白嫖拼点了)
3. 拼点目标不是陆抗
只有同时满足以上三个条件 函数才会返回true 否则返回结果为false
例：太史慈(火)的目标判断函数：
...
filterTarget:function(card,player,target){
 return player.canCompare(target);
},
...

想让一名角色能和陆抗一样 不能成为拼点目标 请参考下方写法：
...
ai:{
 noCompareTarget:true,
},
...
什么？为什么要把代码写在AI里面？当然是因为skillTag用着方便啊
类似的 将noCompareTarget改成noCompareSource 可以让玩家不能发起拼点 不过我想一般没人会做这种负面技能

新版本在执行shaBegin等和杀有关的时机时 可以直接在此步骤调整【杀】伤害 而不需要建立额外的技能
例：新黄忠【烈弓】的部分代码
.........
trigger:{player:'shaBegin'},
.........
content:function(){
.........
 if(typeof trigger.extraDamage!='number'){
 trigger.extraDamage=0;
 }
 trigger.extraDamage++;
.........
},

在useCard等时机也可以对【杀】的伤害进行调整
和上面的时机区别在于：如果一张【杀】指定了多个目标 在useCard相关的时机修改【杀】的伤害值时对所有的目标角色都有效 而上面的只对特定的目标有效
例：新版本【酒】的部分代码：
trigger:{player:'useCard'},
filter:function(event){
return event.card&&event.card.name=='sha';
},
forced:true,
content:function(){
if(!trigger.baseDamage) trigger.baseDamage=1;
trigger.baseDamage+=player.storage.jiu;
.........
},

众所周知 有些技能 看起来什么时候都能发动 然而在OL上却只能在出牌阶段内发动如徐盛的【破军】 马云禄的【凤魄】等
判断一名角色是否处在出牌阶段内 使用player.isPhaseUsing()判断即可


关于死后发动的技能
以步练师【追忆】为例讲解一下
zhuiyi:{
audio:2,
trigger:{player:'die'},
//die时机 是死亡结算流程中明置身份牌之后 弃置区域内的牌和结算奖惩之前
direct:true,
skillAnimation:true,
animationColor:'wood',
forceDie:true,
//这个forceDie是重中之重 没有它的话 技能是不会在死后发动的
content:function(){
"step 0"
player.chooseTarget(get.prompt2('zhuiyi'),function(card,player,target){
return player!=target&&_status.event.source!=target;
}).set('forceDie',true).set('ai',function(target){
var num=get.attitude(_status.event.player,target);
if(num>0){
if(target.hp==1){
num+=2;
}
if(target.hp<target.maxHp){
num+=2;
}
}
return num;
}).set('source',event.source);
//以死亡的角色为发起人的事件一定要将forceDie也set为true 否则不能正常结算
"step 1"
if(result.bool){
var target=result.targets[0];
player.logSkill('zhuiyi',target);
player.line(target,'green');
target.recover();
target.draw(3);
}
},
ai:{
expose:0.5,
}
},
chooseUseTarget()
这个函数算不上新函数 不过以前很少用到(因为这个函数并不能在联机模式下使用)
函数的作用是：给定一张卡牌 让玩家选择卡牌的目标并对这些目标使用此牌
例：孙茹【影箭】
player.chooseUseTarget('###是否发动【影箭】？# ##视为使用一张没有距离限制的【杀】',{name:'sha'},false,'nodistance').logSkill='yingjian';
带###的文本为发动时的文字提示（没有指定提示的时候 默认为「选择xxx的目标」） 写成###的形式是为了方便用同一条文本同时设置prompt和prompt2 也可以分成两条文本填在括号里
{name:'sha'} 自然是要使用的卡牌了 除了这种虚拟卡牌以外 也可以填真实卡牌
false 意义在于让此次使用的卡牌不计入使用次数
'nodistance' 是让此次使用的卡牌不受距离限制
后面的logSkill 则是在玩家确定要使用卡牌的情况下 弹出发动的技能
顺便 如果想让目标强制使用卡牌且不能取消的话 在括号里填true就行
除logSkill外 以上参数没有任何顺序要求【图片】

player.getDamagedHp()
用于计算玩家已损失的体力值（若因旧周泰等而导致体力值小于0 则以0作为当前体力值进行计算）
player.changeGroup();
用于切换玩家的国籍
例：player.changeGroup('wei') 即为将玩家的势力切换为魏国
（在国战模式下不影响势力，胜利条件，野心家判断等）
get.isLuckyStar()
用于判断是否开启了【幸运星模式】的选项

另外关于新版本卡牌强命的方法
除原有的wuxieRespondable的mod和norespond的skillTag之外 还可以通过以下的方法实现卡牌强命/不可无懈
例1：麴义【伏骑】
...
content:function(){
trigger.directHit.addArray(game.filterPlayer(function(current){
return current!=player&&get.distance(current,player)<=1;
}));
},
...
useCard事件的directHit列表 即为【不能使用或打出牌响应卡牌】的角色
想让此牌完全不能被响应？把场上所有角色都加进这个列表就行了
例2:SP贾诩【缜略】
...
content:function(){
trigger.nowuxie=true;
},
...
只想让卡牌不能被无懈？直接把nowuxie属性设置为true即可
另外 这一属性也可以在useCard函数的括号内直接设置
例3：貂蝉【离间】
...
targets[1].useCard({name:'juedou'},'nowuxie',targets[0],'noai').animate=false;
...
那个nowuxie就是关键

然后是两个国战模式专用的函数
get.guozhanRank()
用于判断一个武将在国战模式下的强度评级
评级有10个级别 从-1,0,1...一直到6,7,8 级别越高说明武将强度越强
士兵会被判断为-1 非国战原生武将会被判断为0 君主会被判断为7
其他武将将根据自己在lib.guozhanRank（若为鏖战模式 则改为优先以lib.aozhanRank）中的位置来判断强度
例：get.guozhanRank('gz_xunyou')
判断荀攸的强度 结果无论鏖战还是非鏖战都为8
另外 强度小于4的武将是会被AI荀攸马谡吕范直接换掉的

get.guozhanReverse(xxx,yyy)
用于AI判断是否要调整主副将顺序的函数 xxx为主将 yyy为副将 当AI觉得要换时返回值为true 否则为false
荀攸吕范必定会被AI放在主将
其次是是搭配三血武将的邓艾
搭配 三血将/周泰 的 姜维/孙策 则必定会被AI放在副将

game.cardsGotoSpecial()
将卡牌送至ui.special并触发周妃【良姻】用法和game.cardsDiscard类似 不再赘述

phaseZhunbeiBegin/phaseJieshuBegin
新版本的【准备阶段】和【结束阶段】的时机
当然你继续用phaseBegin和phaseEnd也可以


useCard流程中的customArgs
这个恕我难以使用语言描述 不如贴个例子来的实在
例：黄忠【烈弓】部分代码
trigger:{player:'useCardToTargeted'},
logTarget:'target',
check:function(event,player){
return get.attitude(player,event.target)<=0;
},
filter:function(event,player){
if(event.card.name!='sha') return false;
if(event.target.countCards('h')<=player.countCards('h')) return true;
if(event.target.hp>=player.hp) return true;
return false;
},
content:function(){
if(trigger.target.countCards('h')<=player.countCards('h')) trigger.getParent().directHit.push(trigger.target);
if(trigger.target.hp>=player.hp){
var id=trigger.target.playerid;
var map=trigger.getParent().customArgs;
if(!map[id]) map[id]={};
if(typeof map[id].extraDamage!='number'){
map[id].extraDamage=0;
}
map[id].extraDamage++;
}
},

新版本出牌阶段主动技的新参数（均仅在discard为false且lose不为false时有效）
例：卡牌重铸类技能：
...
visible:true,
loseTo:'discardPile',
...
visible参数是让角色失去卡牌的过程中强制视为正面朝上失去
loseTo则是指定将卡牌的去向（默认为.ui.special）

新版本的judge事件中 可以通过设置callback事件 在judgeEnd和judgeAfter时机之前对判定牌进行操作 避免被曹植截胡
例：黄巾雷使【助祭】：
...
content:function(){
trigger.source.judge().callback=lib.skill.fuji.callback;
},
callback:function(){
var evt=event.getParent(2);
if(event.judgeResult.color=='black'){
game.cardsDiscard(card);
evt._trigger.num++;
}
else{
evt._trigger.source.gain(card,'gain2');
}
},
...

player.drawTo();
角色将手牌摸至X张，若角色手牌数不小于X则无事发生
例：李肃【馈珠】：
...
player.drawTo(Math.min(5,target.countCards('h')));
...

getHistory()
这是在1.9.96.8版本添加的新函数 作用是获取玩家当前回合内使用/打出卡牌的所有事件 以及获取玩家当前回合跳过过的阶段
用法会在下面进行讲解
例1 沙摩柯【蒺藜】
...
filter:function(event,player){
return player.getHistory('useCard').length+player.getHistory('respond').length==player.getAttackRange();
},
...
括号里填需要获取的行动的类型即可
目前支持2种事件类型:useCard(使用牌) respond(打出牌)
以一种字符串类型及skipped(本回合跳过过的阶段)
函数返回得到的结果为数组型数据(注：新版本中也可以对damage(角色受到伤害的事件) sourceDamage(角色造成伤害的事件) lose(角色失去卡牌的事件) gain(角色获得卡牌的事件)使用该函数)
例2 刘琦【屯江】中判断本回合是否跳过了出牌阶段的部分
...
if(player.getHistory('skipped').contains('phaseUse')) return false;
...
skipped返回的数组内 包含角色本回合跳过的阶段的名称
注意和player.skipList进行区分
例3 魏蔡文姬【默识】
...
filter:function(event,player){
return player.getHistory('useCard',function(evt){
return evt.isPhaseUsing()&&['basic','trick'].contains(get.type(evt.card));
}).length>0&&player.countCards('h')>0;
},
...
可以通过在getHistory函数中添加一个函数作为参数 来对事件进行过滤
顺便 在本次更新中 一个事件也可以用isPhaseUsing()函数 判断其是否发生在出牌阶段

getLastUsed(X)
获取玩家本回合内使用倒数第X+1张牌的事件 不填默认为0
例：留赞【奋音】
...
filter:function(event,player){
var evt=player.getLastUsed(1);
if(!evt) return false;
var color1=get.color(evt.card);
var color2=get.color(event.card);
return color1&&color2&&color1!='none'&&color2!='none'&&color1!=color2;
},
...

新版本添加了countMark hasMark addMark removeMark
用于对数量型标记进行快速操作
countMark
例：
player.countMark('nzry_huaiju')
返回的就是玩家拥有的【橘】标记的数量
你就站在此地不要走动 待我翻过铁道 去袁术座上给你偷三个橘子去.jpg(滑稽) 
hasMark
例：
player.hasMark('nzry_huaiju')
有时候橘子的数量不重要 有橘子就行#(滑稽) 
当角色拥有某种标记时 返回值为true 否则为false
addMark
例：
player.addMark('nzry_huaiju',3);
一次性获得三个橘子#(滑稽) 
数字可以不填 默认为1
removeMark
用法和addMark一样

在1.9.97.8.1或更高版本中 在lose事件里 可以直接通过event.hs/es/js 来判断一张卡牌在此次失去事件中原先所处的区域
例：陆逊【连营】：
filter:function(event,player){
if(player.countCards('h')) return false;
return event.hs&&event.hs.length;
},
三个参数均为包含卡牌的数组
相比使用card.original判断卡牌来源而言 这种方法不会受到其他插入结算的影响 结果更可靠

game.getGlobalHistory();
类似于getHistory() 用于获取本回合内发生过的 不属于任何角色的一些事件
目前仅支持cardMove参数（cardsDiscard cardsGotoOrdering cardsGotoSpecial等涉及卡牌位置改变的事件）
例：张昭张纮【固政】
var cards=[];
var cards2=[];
game.getGlobalHistory('cardMove',function(evt){
if(evt.name=='cardsDiscard'&&evt.getParent('phaseDiscard')==trigger) cards.addArray(evt.cards.filterInD('d'));
});

event.relatedLose
这是gain事件中 如果获得其他角色的卡牌时 其他角色失去卡牌的事件
例：蒋干【伪诚】
filter:function(event,player){
if(event.source==player&&event.player!=player&&player.hp>player.countCards('h')){
return event.relatedLose&&event.relatedLose.hs&&event.relatedLose.length>0;
}
return false;
},

player.hasUsableCard()
这个函数用于判断一名角色能否使用XX牌
如果该角色手牌中有XX牌 或者能够通过技能使用XX牌 则返回值为true 否则为false
例：判断能否使用【草船借箭】的代码
...
return player.hasUsableCard('caochuan');
...
直接填写要判断的卡牌名称即可

player.inRange(target);
判断target是否在player的攻击范围内
player.inRangeOf(source);
判断player是否在source的攻击范围内

现在cardsGotoOrdering函数 可以通过指定一个事件而不一定是强制使用当前事件 在这个事件之后丢弃所有还在处理区未被移动的卡牌
例：五谷丰登：
contentBefore:function(){
...
var cards=get.cards(num);
game.cardsGotoOrdering(cards).relatedEvent=event.getParent();
...
}
通过将relatedEvent设置为当前事件的parent（即useCard） 在这一事件结束时而不是contentBefore结束时再丢弃所有卡牌

在1.9.98.2以后的新版本中 useCard过程中中的event.card 不再是简单暴力地使用event.cards[0] 而是重新生成的一个{}
在这种情况下 判断这张牌是否为【转化】的卡牌的方法如下：
...
filter:function(event){
return (get.type(event.card,'trick')=='trick'&&event.card.isCard);
},
...
当event.card.isCard为true时 卡牌为非转化卡牌 否则为转化卡牌

在1.9.98.3及以后的版本中 摸牌阶段「取消摸牌」的代码有一定变化
content:function(){
 ...
 trigger.changeToZero();
 ...
},
为什么要使用changeToZero 而不是直接trigger.cancel呢？
因为直接cancel的话 会导致后面的摸牌阶段结束时等时机直接无法生成 司马昭队友直接哭了

同时 要判断一个出牌阶段「有没有被放弃摸牌」的话 需要使用下面的代码
filter:function(event,player){
return !event.numFixed;
},

1.9.98.3及以后的版本添加了「特效接口」 用于自定义某种名称的卡牌/技能的特效
两种特效的设置方式 都是通过在lib.animate中添加函数 来实现特定卡牌的特效
例：设置【杀】的自定义特效
lib.animate.card.sha=(card,name,nature){
 this.chat('杀一下');
}
这样的话 使用【杀】的时候便不会弹出文字 而是喊一句「杀一下」
this为卡牌的使用/打出者 card为卡牌 nature为不使用特效的情况下卡牌的文字颜色(metal-使用-黄色，wood-打出-绿色)，可以用来判断卡牌是因使用还是因打出而播放特效
当然这里的示例很简单 你也可以自己整些高级的
技能特效的设置方式类似
例：设置孙笨【激昂】的特效
lib.animate.skill.jiang=function(name,popname,checkShow){
 this.chat('吾乃江东的小霸王，孙伯符！')
}
name为技能名称 popname为原先发动技能时弹出的文字（绝大多数情况下与name相同） checkShow为双将模式下技能的来源（vice为主将 其他情况下为副将）

getAllHistory
类似getHistory 只不过获取的是整局游戏而不仅仅是当前回合的数据
例：Yui喵的【珍宝】判断整局游戏中因【激昂】获得过的牌的数量
var draw=0;
player.getAllHistory('gain',function(evt){
if(evt.getParent(2).name=='yui_jiang') draw+=evt.cards.length;
});
return draw>=3;

新版本中 get.name, info, suit, color, type等函数 可以通过添加参数，判断一张牌在一名角色手牌区时的牌面信息
例：假设card是一张红桃闪
get.name(card,player);
如果是player这种普通人 返回的依然是shan
但如果player是神关羽 返回的就是sha了
player不填时默认视为卡牌的拥有者 填false时不做判断

另外 get.type的时候要注意
card和player之间记得加一个null 或者在需要把延时锦囊牌视为trick时把null改为'trick'
get.type(card,null,player)

markAuto
快速向storage中添加卡牌并标记(即使storage是undefined)
例：椎名【轻身】
...
'step 2'
if(result.bool&&result.cards.length){
var cards=result.cards;
player.lose(cards,ui.special,'toStorage');
player.markAuto('shiina_qingshen',cards);
game.log(player,'将',cards,'置于武将牌上');
}
...
其中player.markAuto('shiina_qingshen',cards);等同于以下内容
if(!player.storage.shiina_qingshen) player.storage.shiina_qingshen=[];
player.storage.shiina_qingshen.addArray(result.cards);
player.markSkill('shiina_qingshen');

player.getStorage('xxx')
若player.storage.xxx不为undefined则返回player.storage.xxx 为undefined则返回空数组
例：椎名【轻身】
mod:{
attackFrom:function(from,to,num){
 return num-from.getStorage('shiina_qingshen').length;
},
maxHandcard:function(from,num){
 return num+from.getStorage('shiina_qingshen').length;
},
},
这样写可以防止因undefined导致出现NaN或报错

unmarkAuto
和markAuto类似 快速从storage中移出卡牌并判断数组剩余长度 若为0则移除标记
例：椎名【飞燕】
...
'step 1'
if(result.bool){
var cards=result.links;
player.unmarkAuto('shiina_qingshen',cards);
game.cardsDiscard(cards);
player.$throw(cards);
...
}
else event.finish();
...

在1.9.99.1版本更新之后，所有角色经历的lose事件会同时记录到globalHistory中
例：岩泽雅美【奋音】
...
filter:function(event,player){
if(player!=_status.currentPhase) return false;
if(event.name=='lose'&&event.position!=ui.discardPile) return false;
var list=[];
for(var i=0;i<event.cards.length;i++){
var card=event.cards[i];
list.add(card.suit);
}
game.getGlobalHistory('cardMove',function(evt){
if(evt==event||(evt.name!='lose'&&evt.name!='cardsDiscard')) return false;
if(evt.name=='lose'&&evt.position!=ui.discardPile) return false;
for(var i=0;i<evt.cards.length;i++){
var card=evt.cards[i];
list.remove(card.suit);
}
});
return list.length>0;
},
...

game.createCard2
用法和game.createCard完全一致 只不过生成的卡牌洗牌时不会消失

函数式viewAs
以神赵云【龙魂】举例
relonghun:{
audio:'longhun',
//技能发动时机
enable:['chooseToUse','chooseToRespond'],
//发动时提示的技能描述
prompt:'将♦牌当做杀，♥牌当做桃，♣牌当做闪，♠牌当做无懈可击使用或打出',
//动态的viewAs
viewAs:function(cards,player){
var name=false;
var nature=null;
//根据选择的卡牌的花色 判断要转化出的卡牌是闪还是火杀还是无懈还是桃
switch(get.suit(cards[0],player)){
case 'club':name='shan';break;
case 'diamond':name='sha';nature='fire';break;
case 'spade':name='wuxie';break;
case 'heart':name='tao';break;
}
//返回判断结果
if(name) return {name:name,nature:nature};
return null;
},
//AI选牌思路
check:function(card){
if(ui.selected.cards.length) return 0;
var player=_status.event.player;
if(_status.event.type=='phase'){
var max=0;
var name2;
var list=['sha','tao'];
var map={sha:'diamond',tao:'heart'}
for(var i=0;i<list.length;i++){
var name=list[i];
 if(player.countCards('he',function(card){
 return (name!='sha'||get.value(card)<5)&&get.suit(card,player)==map[name];
 })>0&&player.getUseValue({name:name,nature:name=='sha'?'fire':null})>0){
 var temp=get.order({name:name,nature:name=='sha'?'fire':null});
 if(temp>max){
 max=temp;
 name2=map[name];
 }
 }
 }
 if(name2==get.suit(card,player)) return (name2=='diamond'?(5-get.value(card)):20-get.value(card));
 return 0;
}
return 1;
},
//选牌数量
selectCard:[1,2],
//确保选择第一张牌后 重新检测第二张牌的合法性 避免选择两张花色不同的牌
complexCard:true,
//选牌范围：手牌区和装备区
position:'he',
//选牌合法性判断
filterCard:function(card,player,event){
//如果已经选了一张牌 那么第二张牌和第一张花色相同即可
if(ui.selected.cards.length) return get.suit(card,player)==get.suit(ui.selected.cards[0],player);
event=event||_status.event;
//获取当前时机的卡牌选择限制
var filter=event._backup.filterCard;
//获取卡牌花色
var name=get.suit(card,player);
//如果这张牌是梅花并且当前时机能够使用/打出闪 那么这张牌可以选择

if(name=='club'&&filter({name:'shan',cards:[card]},player,event)) return true;
//如果这张牌是方片并且当前时机能够使用/打出火杀 那么这张牌可以选择
if(name=='diamond'&&filter({name:'sha',cards:[card],nature:'fire'},player,event)) return true;
//如果这张牌是黑桃并且当前时机能够使用/打出无懈 那么这张牌可以选择
if(name=='spade'&&filter({name:'wuxie',cards:[card]},player,event)) return true;
//如果这张牌是红桃并且当前时机能够使用/打出桃 那么这张牌可以选择
if(name=='heart'&&filter({name:'tao',cards:[card]},player,event)) return true;
//上述条件都不满足 那么就不能选择这张牌
return false;
},
//判断当前时机能否发动技能
filter:function(event,player){
//获取当前时机的卡牌选择限制
var filter=event.filterCard;
//如果当前时机能够使用/打出火杀并且角色有方片 那么可以发动技能
if(filter({name:'sha',nature:'fire'},player,event)&&player.countCards('he',{suit:'diamond'})) return true;
//如果当前时机能够使用/打出闪并且角色有梅花 那么可以发动技能
if(filter({name:'shan'},player,event)&&player.countCards('he',{suit:'club'})) return true;
//如果当前时机能够使用/打出桃并且角色有红桃 那么可以发动技能
if(filter({name:'tao'},player,event)&&player.countCards('he',{suit:'heart'})) return true;
//如果当前时机能够使用/打出无懈可击并且角色有黑桃 那么可以发动技能
if(filter({name:'wuxie'},player,event)&&player.countCards('he',{suit:'spade'})) return true;
return false;
},
ai:{
respondSha:true,
respondShan:true,
save:true,
//让系统知道角色“有杀”“有闪”“有桃”
skillTagFilter:function(player,tag){
var name;
switch(tag){
case 'respondSha':name='diamond';break;
case 'respondShan':name='club';break;
case 'save':name='heart';break;
}
if(!player.countCards('he',{suit:name})) return false;
},
//AI牌序

order:function(item,player){
if(player&&_status.event.type=='phase'){
var max=0;
var list=['sha','tao'];
var map={sha:'diamond',tao:'heart'}
for(var i=0;i<list.length;i++){
var name=list[i];
 if(player.countCards('he',function(card){
 return (name!='sha'||get.value(card)<5)&&get.suit(card,player)==map[name];
 })>0&&player.getUseValue({name:name,nature:name=='sha'?'fire':null})>0){
 var temp=get.order({name:name,nature:name=='sha'?'fire':null});
 if(temp>max) max=temp;
 }
 }
 max/=1.1;
 return max;
}
return 2;
},
},
//让系统知道玩家“有无懈”
hiddenCard:function(player,name){
return name=='wuxie'&&player.countCards('he',{suit:'spade'})>0;
},
group:['xinlonghun_num','xinlonghun_discard'],
},

联机扩展编写:
前言：
1.用这个方法相当于源码添加武将包（卡包），跳过了一些禁止联机的判断，从而达到扩展联机效果。
2.此教程只介绍了联机武将包和卡包的添加方法，功能性的联机扩展需要自己推。
框架：
game.import("extension",function(lib,game,ui,get,ai,_status){return{name:"扩展名",content:function(config,pack){
 if(config.武将包名英文){
 for(var i in lib.characterPack['武将包名英文']) {
 if(lib.character[i][4].indexOf("forbidai")<0)lib.character[i][4].push("forbidai");
 };
 };//选项触发内容，原因见config
},precontent:function(武将包名英文){
 if(武将包名英文.enable){
 //武将包
 game.import('character',function(){
 var 武将包名英文={
 name:'武将包名英文',//武将包命名（必填）
 connect:true,//该武将包是否可以联机（必填）
 character:{
 //武将格式:
 //"武将名字":["性别","势力",体力,[技能],[]],
 //格式内每一样东西都不能缺少，否则无法导入该武将包及其以下内容
 },//武将（必填）
 characterIntro:{},//武将介绍（选填）
 characterTitle:{},//武将标题（用于写称号或注释）（选填）
 skill:{},//技能（必填）
 translate:{},//翻译（必填）
 perfectPair:{},//珠联璧合武将（选填）
 };
 if(lib.device||lib.node){
 for(var iin 武将包名英文.character){武将包名英文.character[i][4].push('ext:扩展名/'+i+'.jpg');}
 }else{
 for(var iin 武将包名英文.character){武将包名英文.character[i][4].push('db:extension-扩展名:'+i+'.jpg');}
 }//由于以此法加入的武将包武将图片是用源文件的，所以要用此法改变路径
 return 武将包名英文;
 });
 lib.config.all.characters.push('武将包名英文');
 if(!lib.config.characters.contains('武将包名英文')) lib.config.characters.push('武将包名英文');
 lib.translate['武将包名英文_character_config']='武将包名';// 包名翻译
 //卡包（手牌）
 game.import('card',function(){
 var 卡包名英文={
 name:'卡包名英文',//卡包命名
 connect:true,//卡包是否可以联机
 card:{
 '卡名':{
 image:'ext:扩展名/卡名.jpg', //卡牌图片
 //以下与一般卡牌一样
 },//卡格式
 skill:{},//技能
 translate:{},//翻译
 list:[],//牌堆添加
 };
 return 卡包名英文;
 });
 lib.translate['卡包名英文_card_config']='卡包名';
 lib.config.all.cards.push('卡包名英文');
 if(!lib.config.cards.contains('卡包名英文')) lib.config.cards.push('卡包名英文');//包名翻译
 };
},config:{
 "武将包名英文":{"name":"将武将包名内武将设为禁用","init":false},
 //由于以此法添加的武将包自带的禁用按钮无法使用，需要写这个选项来禁用该武将包武将（单机）
},help:{},package:{
 character:{
 character:{
 },
 translate:{
 },
 },
 card:{
 card:{
 },
 translate:{
 },
 list:[],
 },
 skill:{
 skill:{
 },
 translate:{
 },
 },
 intro:"",
 author:"Aurora",
 diskURL:"",
 forumURL:"",
 version:"",
},files:{"character":[],"card":[],"skill":[]}}})
注意事项：
1.有些函数触发时，主机不会发送触发内容给客机，这是就要用game.broadcastAll(function(){})或game.broadcast (function(){})。（具体用法看源码，不举例）
2.如果是储存类的联机扩展（不如联机皮肤什么的）解决方法：
（1）数据位于服务器，直接读取。
（2）数据位于本地，在主机将信息发送给客机时改动。（我找不到端口，不具体说明）
3.联机时，客机扩展要和主机一致，否则客机发生错误。
4.同一个扩展可以以此法添加多个武将包或卡包。

无名杀扩展配音:
第一种方法是无须将配音文件放在扩展内的，如果要将配音文件打包到扩展内就是另一种写法，先讲武将技能的。编辑器直接写audio:2,就行了，保存后会自动变成audio:"ext:扩展名:2", 其他地方要写成audio:"ext:扩展名:2",将配音打包一起导入很方便玩家。。。。。。很多人写扩展时起的技能名会直接起中文名（如图），这样虽然也能保存，但问题重重，因为这种忽视掉技能ID的做法会让配音失灵，而且如果你是直接引用其他技能甚至是其他扩展的技能，会出现技能与原技能效果一样甚至有一大堆BUG卡死游戏，毕竟不是每个人安装的扩展都一样。所以写技能最好要写ID，切记：ID要唯一，不能与其他技能的ID一样，而且最好尽量用英文小写！！！否则自带编辑器会保存不了，即使用其他软件编辑也会有问题。
技能ID格式：id+|+技能中文名 ，| 是英文输入法下输入的长竖。ID要唯一，不能重复，如我想重写个攻心，ID起gongxin ，它就会提示与现有的重复。所以我另起一个xingongxin，它就能保存了，保存后这个ID会隐藏的， 然后你的配音文件就命名为xingongxin1和xingongxin2放到扩展文件夹里就行，有了这个ID，它就会定向找到这两个文件并随机播放其中一个！这里有一个要注意的地方，整个技能内的所有技能凡出现都要统一，不能外面写xingongxin，然后里面还是gongxin。武将命名最好也用这个格式。
常见问题：有些触发类的技能在武将简介处明明有声音，也有配音接口代码audio:"ext:扩展名:2",，但游戏过程中却没有声音！这是因为direct:true,在捣乱，它是直接跳过询问到下一步所以没声音，那该怎么办？删除这句又会降游戏体验。这时只需logSkill一下（终于知道这句有什么用了吧），在content:function里面合适的步骤（比如一般在if(result.bool){ ）这句里面加一句player.logSkill('id');即可。补充一下：有些简介有声音游戏中没声音，还有个原因是这个技能是技能组，游戏时响应的是子技能，所以配音要配子技能的，配音文件名也是对应子技能的。
卡牌配音问题：有些卡牌是没有引用卡牌技能而是直接将技能写在卡面上的，你会发现写这句接口代码audio:"ext:扩展名:2", 已经没用，解决办法是写成audio:true, 但要将配音文件放在游戏主目录audio-card-male/female里各一个，很麻烦，有没有更好的办法？有！
那就是在主函数区重新定义一个播放函数game.playxxx ，比如：
game.playXu = function(fn, dir, sex) {
if (lib.config.background_speak) {
if (dir && sex)
game.playAudio(dir, sex, fn);
else if (dir)
game.playAudio(dir, fn);
else
game.playAudio('..', 'extension', '扩展包名', fn);
}
};
然后在代码里的content:function 或precontent:function里写
game.playXu([‘xxx1’,’xxx2’].randomGet());即可
。注：群英会扩展用了game.playXu函数，为避免重复，可另改一个名game.playAs、game.playCXK……都行

扩展阵亡配音写法（可一起打包）：
 lib.skill._zhengwangpeiyin={
 trigger:{global:'dieBegin',},
//direct:true,
priority:2,
forced:true,
 unique:true,
 frequent:true,
 /*filter:function (event,player){
 return !event.player.isAlive();
 },*/
 content:function(){
//方法一： 
 game.playAudio('..','extension','扩展包名',trigger.player.name);
//另一种陈列写法： 
 /* if(trigger.player.name=='xwj_xhuoying_itachi'){
 game.playXu('itachi'); 
 }*/ 
 
 },
 }
注：将这段代码复制到主代码区里，建议将zhengwangpeiyin重新改另一个名，前面的_不能删，扩展包名必须改成你的扩展名，阵亡配音文件改成与你的武将id一致。

